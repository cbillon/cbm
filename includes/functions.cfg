#!/bin/bash

RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELOW=$(tput setaf 3)
BLUE=$(tput setaf 14)
NC=$(tput sgr 0)

function info() { [ "$DEBUG" = false ] && echo "${BLUE}" "${@}" "${NC}" || echo "${BLUE}" "${@}" "${FUNCNAME[1]}" line:"${BASH_LINENO[0]}" "${NC}"; }
function warn() { [ "$DEBUG" = false ] && echo "${YELOW}" "${@}" "${NC}" || echo "${YELOW}" "${@}" "${FUNCNAME[1]}" line:"${BASH_LINENO[0]}" "${NC}"; }
function error() { [ "$DEBUG" = false ] && echo "${RED}" "${@}" "${NC}" || echo "${RED}" "${@}" "${FUNCNAME[1]}" line:"${BASH_LINENO[0]}" "${NC}"; }
function success() { [ "$DEBUG" = false ] && echo "${GREEN}" "${@}" "${NC}" || echo "${GREEN}" "${@}" "${FUNCNAME[1]}" line:"${BASH_LINENO[0]}" "${NC}"; }

function check_command() {
  if [[ $? -ne 0 ]]; then
    error "Error execution" "${FUNCNAME[1]}" line:"${BASH_LINENO[0]}" command: "${@}"
    exit 1
  fi
}

function wait_keyboard () {
  read -n 1 -s -r -p "${1:-'Press any key to continue'}"
}

function nothing_todo () {
   
   info 'Wait keyboard input'
   wait_keyboard

}

function setx_output () {
  # dump set -x data to a file
  # turns on with a filename as $1
  # turns off with no params
  if [[ $1 ]]; then
    exec {BASH_XTRACEFD}>>"$1"
    set -x
  else
    set +x
    unset -v BASH_XTRACEFD
  fi
}

function Start () {
  local lvl
  lvl="${#FUNCNAME[@]}"
  indent=''
  for ((i=1; i<=$((lvl-1)); i++));
  do
    indent+=' '
  done
  echo -e "$indent" "${FUNCNAME[1]}" "$*" Start "${BASH_LINENO[0]}" \("${FUNCNAME[2]}":"${BASH_LINENO[1]}"\)

}

function End () {
  local lvl
  lvl="${#FUNCNAME[@]}"
  indent=''

  for ((i=1; i<=$((lvl-1)); i++));
  do
    indent+=' '
  done
  echo -e "$indent" "${FUNCNAME[1]}" "End " "${BASH_LINENO[0]}" \("${FUNCNAME[2]}":"${BASH_LINENO[1]}"\)

}

function get_project_conf () {
  # $1 : PROJECT
  Start "$*"

  PROJECT_BRANCH=$(jq -r .project.branch "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  PROJECT_MOODLE_VERSION=$(jq -r .moodle.version "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  [ "$DEBUG" = true ] && info PROJECT_MOODLE_VERSION: "$PROJECT_MOODLE_VERSION"
  if [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-3]\+?|^[4-5]\.[0-3]\.[0-9]\+?$ ]]; then
    MOODLE_VERSION="${PROJECT_MOODLE_VERSION:0:3}"
    [ "$DEBUG" = true ] && info MOODLE_VERSION: "$MOODLE_VERSION"
  # la branche de la version MOODLE majeure est obtenue par moodle-version.json
    MOODLE_BRANCH=$(jq -r '."'${MOODLE_VERSION}'".branch' "$RACINE"/moodle-versions.json)
    [ "$DEBUG" = true ] && info MOODLE_BRANCH: "$MOODLE_BRANCH"
    if [[ "$MOODLE_BRANCH" != null  ]]; then
      [ "$DEBUG" = true ] && info "Moodle: $MOODLE_VERSION Branch: $MOODLE_BRANCH"
    else
      error "Version ${MOODLE_VERSION} unknown"
    exit 1
    fi
  else
    # on doit tester si |^[a-f0-9]{7,40} !
    error "Version ${MOODLE_VERSION} unknown"
  fi

  End
}

function get_pluglist () {
  Start "$*"
  error=0
  local now diff filedate
  if [ -f pluglist.json ]; then
    now=$(date +'%Y-%m-%d')
    filedate=$(stat pluglist.json | grep -E '^.*Modify:.*$' | cut -d ' ' -f 2)
    diff=$((($(date -d "$now" +%s) - $(date -d "$filedate" +%s))/86400))
    [ "$DEBUG" = true ] && info Diff days: $diff
    [[ "$diff" -lt "$DIFF_DAYS" ]] || wget download.moodle.org/api/1.3/pluglist.php -O pluglist.json
  else
    wget download.moodle.org/api/1.3/pluglist.php -O pluglist.json
  fi

  End
  return "$error"
}

function create_file () {
  error=0
  if [ ! -f "$1" ];then
    touch "$1"
  fi
}

function create_dir () {
  error=0
  if [ ! -d "$1" ];then
    mkdir -p "$1"
  fi
}

function menu () {
  whiptail "$@" 3>&1 1>&2 2>&3 3>&-
  return "$?"
}

function is_project_branch () {
  cd "$MOODLE_SRC" || exit
  [[ $(git branch | grep "$PROJECT_BRANCH") ]] && return 0 || return 1
}

function is_official_plugin () {
  local var
  PLUGIN="$1"
  jq -r --arg plugin  "$PLUGIN" '.plugins|map(select(.component == $plugin)) | .[]' "$RACINE"/pluglist.json > "$RACINE"/tmp.json
  var=$(jq '.id' "$RACINE"/tmp.json)
  [[ -n "$var" ]] && return 0 || return 1    
}

function is_moodleversion_supported () {  
  # $1 PLUGIN
  # $2 MOODLE_VERSION
  # out if PLUGIN supports MOODLE_VERSION
  # VCS_URL
  # DOWNLOAD_URL
  Start "$*"  
  local error vcs download plugin_min_version plugin_max_version
  error=0
  PLUGIN="$1"
  MOODLE_VERSION="$2"

  VCS_URL=null
  DOWNLOAD_URL=null
  
  jq -r --arg plugin  "$PLUGIN" '.plugins|map(select(.component == $plugin)) | .[]' "$RACINE"/pluglist.json > "$RACINE"/tmp.json
  if [[ $(jq '.id' "$RACINE"/tmp.json) ]]; then 
    VCS_URL=$(jq -r '.source' "$RACINE"/tmp.json)
    info VCS_URL: "$VCS_URL"
    plugin_min_version=$(jq -r '.versions[].supportedmoodles[].release' "$RACINE"/tmp.json | sort  | head -n 1) || true
    plugin_max_version=$(jq -r '.versions[].supportedmoodles[].release' "$RACINE"/tmp.json | sort -rn | head -n 1) || true
    info "$PLUGIN" Moodle version supported Min: "$plugin_min_version" Max: "$plugin_max_version"
    PLUGIN_MOODLE_VERSION=$(jq -r '[.versions[]| {(.version) : (.supportedmoodles[].release)} ]' "$RACINE"/tmp.json | grep ': '"$MOODLE_VERSION" | sort -nr | grep -E -o  "([0-9]{10})" | cut -f 1 -d " ") || true
    [[ -n "$PLUGIN_MOODLE_VERSION" ]] && info "$PLUGIN": "$MOODLE_VERSION" supported || { info "$PLUGIN" no metadata specific version "$MOODLE_VERSION"; }
    vcs=$(jq -r '.versions[]|{(.supportedmoodles[].release) : .vcsrepositoryurl}' "$RACINE"/tmp.json | grep ': '"$MOODLE_VERSION" | head -n 1) || true
    if [[ "$vcs" =~ ^.*' "'(.*)'"'$ ]]; then
      VCS_URL="${BASH_REMATCH[1]}"
    else
      info no vcs url value  for specific version
    fi
    download=$(jq -r '.versions[]|{(.supportedmoodles[].release) : .downloadurl}' "$RACINE"/tmp.json | grep "$2"  |  head -n 1) || true    
    if [[ "$download" =~ ^.*' "'(.*)'"'$ ]]; then
      DOWNLOAD_URL="${BASH_REMATCH[1]}"
    else
      DOWNLOAD_URL=null
      error no value for download url
    fi
  else
    error "$PLUGIN"  not in official repository
    error=1 
  fi
    
  [ "$DEBUG" = true ] && info vcs "$vcs" download: "$download"
  
  [ "$DEBUG" = true ] && info VCS URL: "$VCS_URL" DOWNLOAD URL: "$DOWNLOAD_URL"
  
  End
  return
}

function is_version_valid () {
    [ "$DEBUG" = true ] && info MOODLE_VERSION: "$1"
    [[ "$1" =~ ^[4-5]\.[0-5]\+?$|^[4-5]\.[0-5]\.[0-4]\+?$|^[a-f0-9]{7,40} ]] && return 0 || return 1
}

function is_conf_file () {
  [ -d "$PROJECTS_PATH"/"$PROJECT" ] || return 1
  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ] || { error Project "$PROJECT" not exists; return 1; }
  jq . "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json >/dev/null  || { error invalid config file; return 1; }
}

function create_env () {

  # create repository
  if [ ! -d "$PROJECTS_PATH" ]; then
    mkdir "$PROJECTS_PATH"
    cd "$PROJECTS_PATH" || exit
    git init -b main
    success Repository "$PROJECTS_PATH" created
  fi
  create_dir "$PLUGIN_REPO"

}

function create_commit () {

  cd "$PROJECTS_PATH" || exit
  if [[ $(git status --porcelain) ]]; then
    if [ -z "$1" ]; then
      error commit message undefined
      exit
    else
      git add .
      git commit -m "$1"
    fi
  fi
}

function get_moodle_desired_state () {
  Start "$*"
  # get project requested state
  # PARAM IN  : $1 PROJECT
  #       OUT :
  #             PROJECT_MOODLE_VERSION (from <project>.json)
  #             MOODLE_VERSION
  #             MOODLE_BRANCH
  #             MOODLE_DESIRED_STATE (as commit if MOODLE_SRC exists)
  error=0

  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ]

  jq . "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json >/dev/null || {
     error Syntax error : "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
     exit 1
   }

  MOODLE_DESIRED_STATE=''

  if [[ -d "$MOODLE_SRC" ]]; then
    cd "$MOODLE_SRC" || exit
    if [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-3]$ ]]; then
    #for example 4.5
      [ "$DEBUG" = true ] && info "Latest available release $PROJECT_MOODLE_VERSION"
      echo "latest available release $PROJECT_MOODLE_VERSION"
      git checkout "$MOODLE_BRANCH" --quiet
      tags=$(git tag -l v"$PROJECT_MOODLE_VERSION"*)
      [ -z "$tags" ] && error Tags are missing!  && exit 1
      [ "$DEBUG" = true ] && info Tags: "$tags"
      MOODLE_DESIRED_STATE=v${tags##*v}
      [ "$DEBUG" = true ] && info MOODLE_DESIRED_STATE: "$MOODLE_DESIRED_STATE"
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-5]\+$ ]]; then
      #for example 4.5+
      git checkout "$MOODLE_BRANCH" --quiet
      MOODLE_DESIRED_STATE="$MOODLE_BRANCH"
      [ "$DEBUG" = true ] && info Latest available release "$PROJECT_MOODLE_VERSION" with fixes: "MOODLE_DESIRED_STATE"
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-5]\.[0-4]$ ]]; then
      #for example 4.5.1
      git checkout "$MOODLE_BRANCH" --quiet
      [[ $(git tag -l "v${PROJECT_MOODLE_VERSION}") ]] || (error "Release $PROJECT_MOODLE_VERSION not exists" && exit 1)
      MOODLE_DESIRED_STATE=v$PROJECT_MOODLE_VERSION
      [ "$DEBUG" = true ] && info Specific release in "$PROJECT_MOODLE_VERSION" : "MOODLE_DESIRED_STATE"
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-5]\.[0-4]?\+$ ]]; then
      error Specific release with fixes in "$PROJECT_MOODLE_VERSION" not yet supported...
      error=1
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[a-f0-9]{7,40}$ ]]; then
      [ "$DEBUG" = true ] && info "force commit $PROJECT_MOODLE_VERSION"
      local branch
      branch=$(git branch --contains "$PROJECT_MOODLE_VERSION")
      if [[ "$branch" =~ ^.*(MOODLE_[0-9]{2,3}_STABLE).*$ ]]; then
        [ "$DEBUG" = true ] && info Commit "$PROJECT_MOODLE_VERSION" branch found: "${BASH_REMATCH[1]}"
         MOODLE_BRANCH="${BASH_REMATCH[1]}"
         MOODLE_DESIRED_STATE="$PROJECT_MOODLE_VERSION"
      else
        error no branch MOODLE_XXX_STABLE found
        error=1
      fi
    else
      error Moodle version nothing found
      error=1
    fi
  else
  # current when no MOODLE repo
    warn Moodle source repository not present
  fi

  if [[ -d "$MOODLE_SRC" ]]; then
    info git checkout "$MOODLE_DESIRED_STATE"
    git checkout "$MOODLE_DESIRED_STATE" --quiet
    #local current state
    #current_state=$(git rev-parse --short HEAD)
    #CURRENT_STATE="${current_state:0:7}"
    CURRENT_STATE=$(git rev-parse --short HEAD)
  fi

  [ "$DEBUG" = true ] && info PROJECT_MOODLE_VERSION: "$PROJECT_MOODLE_VERSION"
  [ "$DEBUG" = true ] && info MOODLE_VERSION: "${MOODLE_VERSION:-}"
  [ "$DEBUG" = true ] && info MOODLE_BRANCH: "$MOODLE_BRANCH"
  [ "$DEBUG" = true ] && info MOODLE_DESIRED_STATE: "$MOODLE_DESIRED_STATE"
  [ "$DEBUG" = true ] && info CURRENT_STATE: "${CURRENT_STATE:-}"

  End
  return "$error"
}

function repo_need_upgrade () {
  # 1 repository
  # 2 branch
  Start "$*"
  local error repo branch local remote base
  error=0
  repo="$1"
  branch="$2"
  [ "$DEBUG" = true ]&& info repo: "$repo"
  [ "$DEBUG" = true ]&& info branch: "$branch"
  cd "$repo" || exit
  git checkout "$branch" --quiet

  git remote | grep upstream >/dev/null || error no remote upstring
  
  local=$(git rev-parse @)
  remote=$(git rev-parse @{u})
  base=$(git merge-base @ @{u})

  [ "$DEBUG" = true ]&& info local:  " ${local:0:7}"
  [ "$DEBUG" = true ]&& info remote: "${remote:0:7}"
  [ "$DEBUG" = true ]&& info base:   "  ${base:0:7}"

  if [ "$local" = "$remote" ]; then
    success "$repo branche $branch up-to-date with branch remote"
    error=0
  elif [ "$local" = "$base" ]; then
    warn "$repo branche $branch need to pull from remote"
    error=1
  elif [ "$remote" == "$base" ]; then
    warn "$repo branche $branch need to push to remote"
    error=2
  else
    error "$repo branche $branch diverged with remote"
    error=3
  fi

  End
  return "$error"

}

function config_check () {

# 1 PROJECT

  Start "$*"
  local error
  [ "$DEBUG" = true ] && info Project: "$PROJECT"

  error=0
  nano "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
  # check validity .json  
  is_conf_file
  # check PROJECT_MOODLE_VERSION
  get_project_conf "$PROJECT"
  # is up to date
  
  get_plugins "$PROJECT"
  for PLUGIN in "${PLUGINS[@]}"; do
    info "Check plugin: $PLUGIN"
    # check if plugin exists in cache
    if [[ -d "$PLUGIN_REPO"/"$PLUGIN" ]]; then
      cd "$PLUGIN_REPO"/"$PLUGIN" || exit
      
    else
      [ "$DEBUG" = true ] && info "$PLUGIN" missing
    
    fi
    [ "$DEBUG" = true ] && info "$PLUGIN" in local cache


  done

  [ "$error" -eq 0 ] && success Configuration file "$PROJECT" successful || error Please correct configuration file and retry

  End
  return
}

function is_plugin_branch () {
# 1 PLUGIN
# 2 branch
# check if exists upstream/"$2"
  if [[ -n $(git rev-parse --verify upstream/"$2" 2>/dev/null) ]]; then
    git checkout "$2" --quiet || git branch "$2" upstream/"$2"
    info plugin branch "$2" selected for "$1"
    return 0
  else
    return 1
  fi
}

function search_plugin_state_old () {
  Start "$*"
  # IN:  $PROJECT
  #      $PLUGIN
  # OUT: $PLUGIN_BRANCH
  #      $PLUGIN_VERSION
  # PLUGIN must be present in cache
  local search
  error=0

  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ] || exit 1
  PLUGIN="$1"
  get_plugin_params "$PROJECT" "$PLUGIN"
  cd "$PLUGIN_REPO"/"$PLUGIN" || exit 1
  # if already determined return  
  [[ "$PLUGIN_VERSION" != null ]] && info PLUGIN_VERSION "$PLUGIN_VERSION" from config && return 0
  [[ "$LOCALDEV" != null ]] && info LOCALDEV "$LOCALDEV" from config && return 0
  [[ "$PLUGIN_BRANCH" != null ]] && info PLUGIN_BRANCH "$PLUGIN_BRANCH" from config && return 0

  PLUGIN_BRANCH=''
  PLUGIN_VERSION=''

  if [[ $(git branch -r | grep -E "^  upstream\/$MOODLE_BRANCH$") ]]; then
    git checkout "$MOODLE_BRANCH" --quiet || git checkout -b "$MOODLE_BRANCH" upstream/"$MOODLE_BRANCH" --quiet
    PLUGIN_BRANCH="$MOODLE_BRANCH"
    info "Bingo Moodle branch $MOODLE_BRANCH match !"
    return 0
  fi

  # search if branch remote MOODLE_XXX_STABLE

  if [[ $(git branch -r | sort -rn | grep -E "^  upstream\/MOODLE_.*" | head -n 1) ]]; then
    local branch
    branch=$(git branch -r | sort -rn | grep -E "^  upstream\/MOODLE_.*" | head -n 1)
    git checkout "${branch:11}" --quiet || git checkout -b  "${branch:11}" "$branch"
    PLUGIN_BRANCH="${branch:11}"
    info "Found remote branch ${branch:11}"
    return 0
  fi
    # search if exists tag supporting MOODLE_XXX_STABLE

  [[ "$MOODLE_BRANCH" =~ MOODLE_(.*)_STABLE ]] && search="${BASH_REMATCH[1]}" || error Moodle Version not found
  for tag in $(git tag -l | sort -r ); do
    git checkout "$tag" --quiet
    [[ $(cat version.php) =~ .*supported.*"$search" ]] && PLUGIN_VERSION="$tag" && break
  done
  if [[ -n "$PLUGIN_VERSION" ]]; then
    info MOODLE_"$search"_STABLE tag found
    PLUGIN_VERSION="$tag"
    #PLUGIN_BRANCH=$(echo $(git branch --contains $(git rev-parse --short "$tag")) | rev | cut -d' ' -f1 | rev)
    PLUGIN_BRANCH=$(git branch --contains $(git rev-parse --short "$tag") | rev | cut -d' ' -f1 | rev)
    info Found "$tag" version comptible with "$MOODLE_BRANCH"
    return 0
  fi
  is_plugin_branch "$PLUGIN" master && PLUGIN_BRANCH=master && return 0
  is_plugin_branch "$PLUGIN" main && PLUGIN_BRANCH=main && return 0

  error no branch found for "$PLUGIN"
  error=1

  End
return "$error"

}

function create_project () {
  Start "$*"
  # 1 project
  # 2 moodle version
  [ -d "$PROJECTS_PATH"/"$1" ] && error Project "$1" already exists && exit 1
  #create_dirs
  create_dir "$PROJECTS_PATH"/"$1"
  create_dir "$PROJECTS_PATH"/"$1"/env
  create_file "$PROJECTS_PATH"/"$1"/"$1".json
  create_dir "$PROJECTS_PATH"/"$1"/env/dev
  create_file "$PROJECTS_PATH"/"$1"/env/dev/config.php

  # {
  #   echo "# Configuration de $1";
  #   echo "# Created by $USER " "$(date)";
  #   echo "";
  #   echo "project:";
  #   echo "  name: $1";
  #   # by default PROJECT BRANCH = PROJECT
  #   echo "  branch: $1";
  #   echo "";
  #   echo "moodle:";
  #   echo "  version: $2";
  #   echo "";
  #   echo "plugins:";
  # } >>"$PROJECTS_PATH"/"$1"/"$1".json

  PROJECT="$1"
  PROJECT_VERSION="$2"
  sed -e "s/\${project}/$PROJECT/" -e "s/\${version}/$PROJECT_VERSION/" "$RACINE"/template > "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
  get_project_conf "$PROJECT"
  
  #create_commit "Project $PROJECT created"

  # Initialisation signal erreur
  error=0

  #[ "$DEBUG" = true ] && info MOODLE_BRANCH: "$MOODLE_BRANCH"
  if [ -d "$MOODLE_SRC" ]; then
    info "$MOODLE_SRC" already exists
    cd "$MOODLE_SRC" || exit
    git fetch upstream --tags --quiet
    if [[ ! $(git branch --list | grep "^.*$MOODLE_BRANCH") ]]; then
      info "Branch $MOODLE_BRANCH not exists create branch"
      git branch "$MOODLE_BRANCH" remotes/upstream/"$MOODLE_BRANCH"
      # git remote set-branches upstream "$MOODLE_BRANCH" || check_command "error git remote set-branches upstream $MOODLE_BRANCH"
      #git fetch upstream "$MOODLE_BRANCH" --tags --quiet || check_command "error git fetch upstream $MOODLE_BRANCH --tags --quiet"
    else
      update_moodle "$PROJECT"
    fi
  else
    info "$MOODLE_SRC" does not exists
    if [[ "$DEPTH" -gt 0 ]]; then
      git clone --branch "$MOODLE_BRANCH" --depth "$DEPTH" "$MOODLE_DEPOT"  "$MOODLE_SRC"
    else
      git clone --branch "$MOODLE_BRANCH" "$MOODLE_DEPOT"  "$MOODLE_SRC"
    fi
    cd "$MOODLE_SRC" || exit
    git remote add upstream "$MOODLE_HQ"
  fi
  get_moodle_desired_state
  # Create project branch
  cd "$MOODLE_SRC" || exit
  git branch "$PROJECT_BRANCH" "$MOODLE_DESIRED_STATE"
  info Branch "$PROJECT_BRANCH" from "$MOODLE_DESIRED_STATE" created

  git checkout "$PROJECT_BRANCH" --quiet

  End
  return "$error"

}

function update_moodle () {
  Start "$*"
  local error
  error=0

  get_project_conf "$PROJECT"

  cd "$MOODLE_SRC" || exit
  git checkout --quiet "$MOODLE_BRANCH"
  git fetch upstream

  get_moodle_desired_state "$PROJECT"

  repo_need_upgrade "$MOODLE_SRC" "$MOODLE_BRANCH" || error="$?"
  case "$error" in
    0)
      success "$MOODLE_SRC" "$MOODLE_BRANCH" up to date
      ;;
    1)
      info Moodle branch "$MOODLE_BRANCH" need update
      git checkout "$MOODLE_BRANCH" --quiet
      git merge --ff-only  upstream/"$MOODLE_BRANCH" --quiet
      info Branch "$MOODLE_BRANCH" updated from upstream
      # update project
      info PROJECT_BRANCH: "$PROJECT_BRANCH"
      git checkout "$PROJECT_BRANCH" --quiet
      git merge "$MOODLE_BRANCH"
      success "$PROJECT_BRANCH" merged after Moodle update
      error=0
      ;;
    *)
      error "$error" see previous message
      ;;
  esac

  End
  return "$error"

}

function list_plugins_cache () {
  Start "$*"
  error=0
  i=0
  list=''
  for d in $(ls -l "$PLUGIN_REPO" | awk '{print $9}' | sort);
  do
    i=$((i+1))
    list="$list $d $i OFF"
  done
  
  menu --title "Plugins cache" --checklist "Plugin's List(cache)" 25 78 16 $list

  #sortie=0
  End
}

function get_plugin_dir () {
  # IN: $PLUGIN  type_component name
  # OUT: $DIR
  Start "$*"
  error=0
  # le fichier components.json permet de determiner le repertoire de destination a partir du type de plugin
  # pour convertir au format yaml : jq -oy components.json > components.json
  #https://blog.kiprosh.com/regular-expressions-greedy-vs-non-greedy/ type_stype_name
  # doesn t works wit bash !
  # if plugin type valid DIR is set
  local ss error
  error=0
  if [[ "$1" =~ ^[a-z].*?_.*$ ]];
  then
    PLUGIN="$1"
    ss=${1#*-}
    COMPONENT_NAME=${1#*_}
    TYPE=${ss%%_*}
    DIR=$(jq -r .plugintypes."$TYPE" "$RACINE"/types.json)
    [ "$DEBUG" = true ] && info PLUGIN: "$PLUGIN"
    [ "$DEBUG" = true ] && info TYPE: "$TYPE"
    [ "$DEBUG" = true ] && info COMPONENT_NAME: "$COMPONENT_NAME"    
    [ "$DEBUG" = true ] && info DIR: "$DIR"
    [ "$DIR" == null ] && error type: "$TYPE" invalide && error=1
  else
    error=1
    error Incorrect plugin syntax "$1"
  fi
  End
  return "$error"

}

function add_plugin_cache () {

  Start "$*"
  error=0
  valid_plugin=1
  while [ "$valid_plugin" -ne 0 ];
  do
    parm=$(menu --inputbox "New plugin (type_name) ?" 8 39 "" --title "Add plugin")
    # en parametre le plugin recherché sous la forme <type>_<name>
    if [[ "$?" -eq 0 ]]; then
      PLUGIN="$parm"
      valid_plugin=0
      info plugin: "$parm"
    #  [ -z "$parm" ] && error "$parm" Parametre plugin missing && valid_plugin=1
    else
      return 1
    fi
  done
  
  if [ -d "$PLUGIN_REPO"/"$PLUGIN" ]; then
    warn "$PLUGIN" already exists
  else    
    get_plugin_dir "$parm" && { PLUGIN="$parm"; valid_plugin=0; } || valid_plugin=1
      [ "$DEBUG" = true ] && info plugin: "$PLUGIN" "$TYPE" "$COMPONENT_NAME"
      # Recherche dans le fichier de référence des plugins
      # Add plugin
    if is_moodleversion_supported "$PLUGIN" "$MOODLE_VERSION"; then
        if [[ "VCS_URL" != null ]]; then 
          info Plugin Source : "$VCS_URL"
          clone_plugin "$PLUGIN" "$VCS_URL"
          success "$PLUGIN locally loaded in cache"
        else
          error "$PLUGIN" not loaded in cache
        fi
    else
        error plugin "$PLUGIN" not found in official plugins directory
        error=1
    fi
  fi
  End
  return "$error"
}

function clone_plugin () {
  # 1 PLUGIN
  # 2 url source
  Start "$*"
  if [ ! -d "$PLUGIN_REPO"/"$PLUGIN" ];
  then
    cd "$PLUGIN_REPO" || exit
    git clone "$2" "$1" --quiet
    cd "$PLUGIN_REPO"/"$1" || exit
    git remote rename origin upstream
  fi
  End

}

function edit_plugins () {
info
  Start "$*"
  error=0

  get_moodle_desired_state
  local date_before date_after
  date_before=$(date -r "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  get_plugins
  plugins_before="$PLUGINS"

  ret=1
  while [ $ret -ne 0 ];
  do
  # exec {STDOUTBACK}>&1
  # exec {STDERRBACK}>&2
  # exec 1>>/dev/pts/0
  # exec 2>>/dev/pts/0
  nano "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
  ret="$?"
  # exec 1>&$STDOUTBACK
  # exec 2>&$STDERRBACK

  # config_check && ret=0 || wait_keyboard 'Error in config file.Press any key and correct'
  done

  date_after=$(date -r "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  if [ "$date_after" != "$date_before" ]; then
     [ "$DEBUG" = true ] && echo "il y a eu des maj..."
    # check validity .json
    jq "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json >/dev/null || exit 1
    get_plugins
    plugins_after="${PLUGINS[@]}"

    # on ne récupere que les plugins uniques donc uniquement ceux supprimés et non aussi ceux ajoutés !
    plugins_suppress=$(echo "$plugins_before" "$plugins_after" "$plugins_after" | tr ' ' '\n' | sort | uniq -u)

    if [ -n "$plugins_suppress" ]; then
      for key in "${!plugins_suppress[@]}"; do
        # skip first entry -[ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ]
        [[ ${plugins_suppress[$key]} == '-' ]] && continue
        echo "A supprimmer: $key ${plugins_suppress[$key]}"
        suppress_plugin "${plugins_suppress[$key]}"
      done
      #create_commit "Update edit_plugins"
      must_update_codebase=1
    fi
  else
    [ "$DEBUG" = true ] && info "Pas de modification de la liste des plugins"
  fi
  if [ -n "${must_update_codebase:-}" ] && [ "$must_update_codebase" -eq 1 ]; then
    update_codebase "$PROJECT"
    success Code base updated
  fi
  End
  return "$error"
}

function get_plugins () {
  
  #in: $PROJECT
  #out: $PLUGINS

  Start "$*"
  if [[ $(jq '.plugins' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json) != null ]]; then
    PLUGINS=($(jq -r ".plugins[].name" "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json | tr "\n" " "))
  else
    PLUGINS=()
    warn plugins list empty
  fi
  [ "$DEBUG" = true ] && info Nb plugins: "${#PLUGINS[@]}"

  End
}

function update_plugins_repo () {

  Start "$*"
  error=0
  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ]

  get_plugins "$PROJECT"

  for PLUGIN in "${PLUGINS[@]}"; do
    [ "$DEBUG" = true ] && info check PLUGIN: "$PLUGIN"
    if [ -d "$PLUGIN_REPO"/"$PLUGIN" ]; then
      get_plugin_desired_state "$PLUGIN"
      repo_need_upgrade "$PLUGIN_REPO"/"$PLUGIN" "$PLUGIN_BRANCH"
      case "$?" in
      0)
        success "$PLUGIN" up to date
      ;;
      1)
        info "Mise à jour automatique du plugin $PLUGIN" from upstream
        git checkout --quiet "$PLUGIN_BRANCH"
        git merge --quiet --ff-only upstream/"$PLUGIN_BRANCH"

        if [ "$LOCALDEV" != null ];
        then
          EXISTS=$(git show-ref refs/heads/"$LOCALDEV")
          if [[ -z $EXISTS ]]; then
            git branch --quiet "$LOCALDEV"
          fi
          git checkout --quiet "$LOCALDEV"
          git rebase --quiet "$PLUGIN_BRANCH"
        fi
      ;;
      2)
        warn "$PLUGIN_BRANCH need to push to remote"
      ;;
      3)
        error "$PLUGIN_BRANCH diverged with remote"
        exit 1
      ;;
      4)
        warn "$PLUGIN" dont have remote upstream
      ;;
      esac
    else
      error "$PLUGIN" missing in local cache
      exit 1
    fi
  done

  End
  return "$error"

}

function get_plugin_params () {
  
  # decode parameters in conf file <project>.json
  # if new parameter add it
  # paramater not present value returned null

  Start "$*"
  #PROJECT="$1"
  #PLUGIN="$2"

  [ -d "$PLUGIN_REPO"/"$PLUGIN" ] || { error Plugin "$PLUGIN" not present; exit 1; }

  PLUGIN_BRANCH=$(jq --arg plugin "$PLUGIN" -r '.plugins[]|select(.name==$plugin).branch' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  PLUGIN_VERSIONNUMBER=$(jq --arg plugin "$PLUGIN" -r '.plugins[]| select(.name==$plugin).versionnumber' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  PLUGIN_VERSION=$(jq --arg plugin "$PLUGIN" -r '.plugins[]|select(.name==$plugin).version' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  
  End
}

function get_plugin_desired_state () {
 
  Start "$*"
  local error=0
  PLUGIN="$1"
  
  # returned parameters from <project>.json
 
  # VERSION (tag)
  # BRANCH
  # VERSIONNUMBER  yyyymmddxx
  
  get_plugin_params "$PLUGIN"

  PLUGIN_STATE_TYPE=null
  PLUGIN_DESIRED_STATE=null
  if [[ "$PLUGIN_VERSION" != null ]]; then
    PLUGIN_STATE_TYPE=version
    PLUGIN_DESIRED_STATE="$PLUGIN_VERSION"
    [ "$DEBUG" = true ] && info   PLUGIN_STATE_TYPE: "$PLUGIN_STATE_TYPE"  from PLUGIN_VERSION
  elif [[ "$PLUGIN_BRANCH" != null ]]; then
    PLUGIN_STATE_TYPE=branch
    PLUGIN_DESIRED_STATE="$PLUGIN_BRANCH"
    [ "$DEBUG" = true ] && info   PLUGIN_STATE_TYPE: "$PLUGIN_STATE_TYPE" from PLUGIN_BRANCH
  elif [[ "$PLUGIN_VERSIONNUMBER" != null ]]; then
    PLUGIN_STATE_TYPE=versionnumber
    PLUGIN_DESIRED_STATE="$PLUGIN_VERSIONNUMBER"
    [ "$DEBUG" = true ] && info   PLUGIN_STATE_TYPE: "$PLUGIN_STATE_TYPE" from PLUGIN_VERSIONNUMBER
  else
    # no value configured search default value
    get_plugin_default_state "$PLUGIN" "$MOODLE_VERSION"  
  fi
  
  [ "$DEBUG" = true ] && info "  PLUGIN_STATE_TYPE: $PLUGIN_STATE_TYPE" PLUGIN_DESIRED_STATE: "$PLUGIN_DESIRED_STATE"  
    
  End
  return "$error"

}

function get_plugin_default_state () {
  
  Start "$*"
  # 1 PLUGIN
  PLUGIN="$1"
  MOODLE_VERSION="$2"
  local error=0

  [ "$DEBUG" = true ] && info PLUGIN: "$PLUGIN"
  [ "$DEBUG" = true ] && info MOODLE_VERSION: "$MOODLE_VERSION"
  
  if is_moodleversion_supported "$PLUGIN" "$MOODLE_VERSION" ; then
    jq -r --arg plugin "$PLUGIN" '.plugins | map(select(.component == $plugin))' "$RACINE"/pluglist.json > "$RACINE"/tmp.json
    VCSTAG=$(jq -r --arg moodle_version "$MOODLE_VERSION" '[.[].versions[]| {version: .vcstag, moodle: .supportedmoodles[].release}]|.[]|select(.moodle == $moodle_version)|.version' "$RACINE"/tmp.json | sort -rn | head -n 1)
    if [[ -n "$VCSTAG" ]]; then
      [ "$DEBUG" = true ] && info Tag: "$VCSTAG"
      PLUGIN_STATE_TYPE=vcstag
      PLUGIN_DESIRED_STATE="$VCSTAG"
    else
      warn "no tag..."
    fi
  else
    error "$PLUGIN" not supports Moodle version "$MOODLE_VERSION"
  #  error=1
  fi
  [ "$DEBUG" = true ] && info Plugin: "$PLUGIN" default state: "$PLUGIN_STATE_TYPE" desired state: "$PLUGIN_DESIRED_STATE" 
  
  End
  return "$error"

}

function get_plugin_observed_state () {
  
  Start "$*"
  PLUGIN="$1"
  STATE_TYPE=null
  STATE=null
  get_plugin_dir "$PLUGIN"
  
  # plugin already installed
  cd "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" || exit
  [[ $(grep .gitrepo -e 'PLUGIN_STATE_TYPE=') =~ ^.*PLUGIN_STATE_TYPE=(.*)$ ]] && STATE_TYPE="${BASH_REMATCH[1]}"
  [[ $(grep .gitrepo -e 'PLUGIN_DESIRED_STATE=') =~ ^.*PLUGIN_DESIRED_STATE=(.*)$ ]] && STATE="${BASH_REMATCH[1]}"
  
  [ "$DEBUG" = true ] && info state type in plugin: "$STATE_TYPE" state: "$STATE"
  End

}

function codebase_need_update () {
  
  Start "$*"
  PLUGIN="$1"
  get_plugin_dir "$PLUGIN"
  if [ -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]; then

    get_plugin_desired_state "$PLUGIN"

    # plugin already installed
    cd "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" || exit
    STATE_TYPE=null
    STATE=null
    [[ $(grep .gitrepo -e 'PLUGIN_STATE_TYPE=') =~ ^.*PLUGIN_STATE_TYPE=(.*)$ ]] && STATE_TYPE="${BASH_REMATCH[1]}"
    [[ $(grep .gitrepo -e 'PLUGIN_DESIRED_STATE=') =~ ^.*PLUGIN_DESIRED_STATE=(.*)$ ]] && STATE="${BASH_REMATCH[1]}"
  
    [ "$DEBUG" = true ] && info state type in plugin: "$STATE_TYPE" state: "$STATE"

    if [ "$PLUGIN_STATE_TYPE" == "$STATE_TYPE" ] && [ "$PLUGIN_DESIRED_STATE" == "$STATE" ]; then
      success "$PLUGIN" type "$STATE_TYPE" state "$PLUGIN_DESIRED_STATE" OK
    else
      install_plugin_project "$PLUGIN" "$PLUGIN_STATE_TYPE" "$PLUGIN_DESIRED_STATE"
    fi
  else
    info "$PLUGIN" not installed
    get_plugin_desired_state "$PLUGIN"
    install_plugin_project "$PLUGIN" "$PLUGIN_STATE_TYPE" "$PLUGIN_DESIRED_STATE"
  fi

  End
}

function install_plugin_project ()  {
  # install plugin (add or update)
  Start "$*"
  local error=0 
  PLUGIN="$1"
  PLUGIN_STATE_TYPE="$2"
  PLUGIN_DESIRED_STATE="$3"

  [ "$DEBUG" == true ] && info PLUGIN_STATE_TYPE: "$PLUGIN_STATE_TYPE" PLUGIN_DESIRED_STATE: "$PLUGIN_DESIRED_STATE"
  
  case "$PLUGIN_STATE_TYPE" in
  "version")
    info PLUGIN_STATE_TYPE "$PLUGIN_STATE_TYPE";;
  "branch")
    info PLUGIN_STATE_TYPE "$PLUGIN_STATE_TYPE";;
  "versionnumber")
    info PLUGIN_STATE_TYPE "$PLUGIN_STATE_TYPE";;
  "vcstag")
    install_plugin_vcstag "$PLUGIN" "Add $PLUGIN" "$PLUGIN_STATE_TYPE" "$PLUGIN_DESIRED_STATE";;
  *)
    error Unknown PLUGIN_STATE_TYPE "$PLUGIN_STATE_TYPE";;
  esac
  
  End
  return "$error"
}

function install_plugin_vcstag () {
  
  Start "$*"
  local error=0 
  PLUGIN="$1"
  MSG="$2"
  PLUGIN_STATE_TYPE="$3"
  PLUGIN_DESIRED_STATE="$4"
  
  [ "$DEBUG" == true ] && info "$1" "$2" "$3" "$4"
  
  [ -d "$PLUGIN_REPO"/"$PLUGIN" ] || { error "$PLUGIN" not in cache; exit; }
  cd "$PLUGIN_REPO"/"$PLUGIN" || exit
  git checkout "$PLUGIN_DESIRED_STATE" --quiet

  cd "$MOODLE_SRC" || exit
  git checkout "$PROJECT_BRANCH" --quiet
  
  get_plugin_dir "$PLUGIN"

  if [ ! -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]; then
    mkdir -p "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"
  fi
  rsync -a --delete --exclude '.git' "$PLUGIN_REPO"/"$PLUGIN/" "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME/"
 
  echo "    PLUGIN_STATE_TYPE=$PLUGIN_STATE_TYPE" > "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo
  echo "    PLUGIN_DESIRED_STATE=$PLUGIN_DESIRED_STATE" >> "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo
  git add .
  git commit -m "${MSG}" --quiet
  
  End
  return "$error"

}

function update_codebase () {
  Start "$*"
  error=0
  get_project_conf "$PROJECT"
  get_plugins "$PROJECT"

  for PLUGIN in "${PLUGINS[@]}"
  do
    info plugin: "$PLUGIN"
    codebase_need_update "$PLUGIN"
  done
  End
}

function update_codebase_old () {

  Start "$*"
  error=0
  # Etape 1 met à jour le depot local de plugin
  #update_plugins_repo "$PROJECT"
  # Etape 2 Pour chaqur plugin du projet recuperation etat souhaité 
  # Etape 3 on compare l'état desiré du plugin à l'état observé : si different mise à jour de la base de code
  # nota :  l'état installé du plugin est sauvegardé dans un fichier ; il contient 2 lignes:
  #         - le type de pramùetre
  #         - la valeur  
  get_project_conf "$PROJECT"
  info PROJECT_BRANCH: "$PROJECT_BRANCH"

  cd "$MOODLE_SRC" || exit  
  git checkout "$PROJECT_BRANCH" --quiet

  get_plugins "$PROJECT"

  for PLUGIN in "${PLUGINS[@]}"; do
    get_plugin_desired_state "$PLUGIN"
    get_plugin_dir "$PLUGIN"
    if [ -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]; then
    # module already installed
      cd "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" || exit
      #for sha1 complet -c11-50 | cut -c11-50
      #COMMIT=$(grep .gitrepo -e 'commit = ')
      [[ $(grep .gitrepo -e 'commit = ') =~ ^.*commit' = '([a-f0-9].*)$ ]] && COMMIT="${BASH_REMATCH[1]}"
      [ "$DEBUG" = true ] && info commit in plugin: "$COMMIT"
      if [[ "$COMMIT" == "$PLUGIN_DESIRED_STATE_SHA1" ]]; then
        # MOD='OK'
        success "$PLUGIN est installe dans $MOODLE_SRC/$DIR/$COMPONENT_NAME et est à jour OK"
      else
        # MOD='UPD'
        warn "$PLUGIN est installe dans $MOODLE_SRC/$DIR/$COMPONENT_NAME mais n est pas à jour UPD"
        cd  "$MOODLE_SRC" || exit
        install_plugin_project "$PLUGIN" "Mise à jour de $PLUGIN"
        success "$PLUGIN mis à jour dans le répertoire $DIR"
      fi
    else
      # MOD='ADD'
      warn "$PLUGIN missing in $MOODLE_SRC/$DIR/$COMPONENT_NAME. ADD"
      info "$PLUGIN type: $TYPE path: $DIR state: $PLUGIN_DESIRED_STATE"
    #  install_plugin_project "$PLUGIN" "Add $PLUGIN / $PLUGIN_DESIRED_STATE in $DIR"
      success "$PLUGIN"/"$PLUGIN_DESIRED_STATE" suscussfully added in "$DIR"
    fi

  done
 must_update_codebase=0
 End
 return "$error"

}

function release () {

Start "$*"
error=0
[ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ]

# $1 MSG for new release

NEWRELEASE="$PROJECT_BRANCH"-$(date +%Y.%m.%d@%Hh%M)
MSG="${1:-$NEWRELEASE}"

info MSG: "$MSG"
cd "$MOODLE_SRC" || exit
[ "$DEBUG" = true ] && info PROJECT_BRANCH: "$PROJECT_BRANCH"
git checkout "$PROJECT_BRANCH" --quiet
git commit --allow-empty -m "$MSG"
git tag -a "$NEWRELEASE" -m ""

# create <PROJECT>.lock
project_lock "$NEWRELEASE"

cd "$MOODLE_SRC" || exit
git checkout "$PROJECT_BRANCH" --quiet
if [ $(git status --porcelain) ];
then
  error update pending dont remote update
else
  if [  -n "${MOODLE_UPDATE_ORIGIN:-}" ]; then
    [ "$DEBUG" = true ] && info MOODLE_UPDATE_ORIGIN: "$MOODLE_UPDATE_ORIGIN"
    remote_origin_url=$(git config remote.origin.url)
    [ "$DEBUG" = true ] && info remote_origin_url: "$remote_origin_url"
    if [ -n "$remote_origin_url" ]; then
      if [ "$remote_origin_url" == "$MOODLE_UPDATE_ORIGIN" ]; then
        git push origin "$PROJECT_BRANCH"
        success "$MOODLE_UPDATE_ORIGIN" successfully updated
      else
        error remote url has changed : "$remote_origin_url"
        error=1
        exit
      fi
    else
      # first time not configured
      info First time configure git add remote origin "$MOODLE_UPDATE_ORIGIN"
      git remote add origin "$MOODLE_UPDATE_ORIGIN"
      success remote add origin "$MOODLE_UPDATE_ORIGIN"
      # The option -u is for “set upstream”.
      #It configures the local branch to track the remote branch.
      # You dont need to use it more than once.
      git push -u origin "$PROJECT_BRANCH"
      success "$MOODLE_UPDATE_ORIGIN" updated
    fi
  fi
fi

End
return "$error"

}

function project_lock () {
  
  local error common_ancestor
  Start "$*"
    
  NEWRELEASE="${1}"
  error=0
  cd "$PROJECTS_PATH"/"$PROJECT" || exit
  # create "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ] || exit
  [ -f "$PROJECT".lock ] && rm "$PROJECT".lock
  cp "$PROJECT".json "$PROJECT".lock

  [ "$DEBUG" = true ] && info PROJECT_BRANCH: "$PROJECT_BRANCH" Moodle: "$MOODLE_BRANCH"
  
  cd "$MOODLE_SRC" || exit
  git checkout "$PROJECT_BRANCH" --quiet
  info MOODLE_BRANCH "$MOODLE_BRANCH"
  jq --arg moodle_branch "$MOODLE_BRANCH" '.moodle.branch=$moodle_branch' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock > "$PROJECT".tmp
  mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock 
  common_ancestor=$(git merge-base  "$PROJECT_BRANCH" "$MOODLE_BRANCH"  )
  jq --arg moodleversion "${common_ancestor:0:7}" '.moodle.version=$moodleversion' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock > "$PROJECT".tmp
  mv -- "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  
  get_plugins "PROJECT"
  for PLUGIN in "${PLUGINS[@]}"; do
    [ "$DEBUG" = true ] &&info "Add lock metadata plugin: $PLUGIN"
    get_plugin_dir "$PLUGIN"
    
  if [[ $(grep 'PLUGIN_STATE_TYPE' < "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo) =~ ^.*=(.*)$ ]]; then
    jq --arg name "$PLUGIN" --arg type "${BASH_REMATCH[1]}" \
    '(.plugins[]|select(.name==$name)).type=$type' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock > "$PROJECT".tmp
    mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock 
  else
    error content type not found  "$PLUGIN"/.gitrepo
  fi

  if [[ $(grep 'PLUGIN_DESIRED_STATE' < "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo) =~ ^.*=(.*)$ ]]; then
    jq --arg name "$PLUGIN" --arg state "${BASH_REMATCH[1]}" \
    '(.plugins[]|select(.name==$name)).state=$state' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock > "$PROJECT".tmp
    mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock 
  else
    error content state not found  "$PLUGIN"/.gitrepo
  fi

  done

  #create_commit "$NEWRELEASE"
  End "$PROJECT"
  return $error
}

function rm_plugin () {
  Start "$*"
  local i list
  
  get_plugins "$PROJECT"
  
  i=0
  list=''
  for PLUGIN in "${PLUGINS[@]}"
  do
    info plugin: "$PLUGIN"
    list="$list $i $PLUGIN OFF"
    ((++i))
  done

  n=$(menu --title "Plugins cache" --radiolist "Project's Plugins List" 25 78 16 $list)
   
  PLUGIN=$(jq -r ".plugins[$n].name" "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  jq "del(.plugins[$n])|." "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json > "$PROJECT".tmp && mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json

  suppress_plugin "$PLUGIN"

  End
}

function suppress_plugin () {

  Start "$*"
  error=0
  PLUGIN="$1"

  info " Suppression du plugin ${PLUGIN}"

  if menu --title "Boite de dialogue Oui / Non" --yesno "Suppression du plugin ${PLUGIN}" 10 60;
  then
    get_plugin_dir "$PLUGIN"
    cd "$MOODLE_SRC" || exit
    git checkout "$PROJECT_BRANCH" --quiet
    if [ -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ];
    then
      rm -r  "${MOODLE_SRC:-?}"/"${DIR:-?}"/"${COMPONENT_NAME:?}"
      git add .
      git commit -m "Suppress plugin $PLUGIN" --quiet
      success "$PLUGIN deleted in codebase"
      wait_keyboard
    else
      warn "Plugin $PLUGIN not present nothing to do!"
    fi
  else
   info 'Abandon !'
  fi

End
}

function add_plugin_project () {

  Start "$*"
  # Retrieve plugins already in configuration file
  #get_plugins "$PROJECT"
  cd "$PLUGIN_REPO" || exit
  local i error must_update_codebase list
  i=0
  must_update_codebase=0
  error=0

  list=''
  for d in $(ls -l "$PLUGIN_REPO" | awk '{print $9}'); do
    # save plugins not in project configuration file
    if [[ -z $(jq -r '.plugins[].name' /home/cb/cbm/projects/"$PROJECT"/"$PROJECT".json | grep "$d" ) ]]; then
      ((++i))
      list="$list $d $i OFF"
    fi
  done

  PLUGINS=$(menu --title "Plugins cache" --radiolist "Plugin's List" 25 78 16 $list)

  for PLUGIN in "${PLUGINS[@]}"; do
    PLUGIN="${PLUGIN//'"'}"
    [ "$DEBUG" = true ] && info projects plugin add: "$PLUGIN"
    if [[ -z $(jq -r '.plugins[].name' /home/cb/cbm/projects/demo/demo.json | grep "$PLUGIN" ) ]]; then
      jq  -r --arg plugin "$PLUGIN" '.plugins[.plugins| length] |= . + { "name": $plugin }' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json > "$PROJECT".tmp && mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
    fi 
  done
  must_update_codebase=1
  End
  return "$error"
}