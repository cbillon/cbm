#!/bin/bash

RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELOW=$(tput setaf 3)
BLUE=$(tput setaf 14)
NC=$(tput sgr 0)

function info() { echo "${BLUE}" "${@}" "${NC}";}
function warn() { echo "${YELOW}" "${@}" "${NC}"; }
function error() { echo "${RED}" "${@}" "${NC}"; }
function success() { echo "${GREEN}" "${@}" "${NC}"; }

# function info() { echo "${@}";}
# function warn() { echo "${@}";}
# function error() { echo "${@}";}
# function success() { echo "${@}"; }

function check_command() {
  if [[ $? -ne 0 ]]; then
    error "Error execution" "${FUNCNAME[1]}" line:"${BASH_LINENO[0]}" command: "${@}"
    exit 1
  fi
}

function wait_keyboard () {
  read -n 1 -s -r -p "${1:-'Press any key to continue'}"
}

function nothing_todo () {

   info 'Wait keyboard input'
   wait_keyboard

}

function setx_output () {
  # dump set -x data to a file
  # turns on with a filename as $1
  # turns off with no params
  if [[ $1 ]]; then
    exec {BASH_XTRACEFD}>>"$1"
    set -x
  else
    set +x
    unset -v BASH_XTRACEFD
  fi
}

function Start () {

  local lvl="${#FUNCNAME[@]}" indent=''  
  for ((i=1; i<=$((lvl-1)); i++));
  do
    indent+=' '
  done  
  #echo -e "$indent" "${FUNCNAME[1]}" "$*" Start "${BASH_LINENO[0]}" \("${FUNCNAME[2]}":"${BASH_LINENO[1]}"\)
  echo -e "$indent" "${FUNCNAME[1]}" "$*" Start "${BASH_LINENO[0]}" 
}

function End () {

  local lvl="${#FUNCNAME[@]}" indent=''
  for ((i=1; i<=$((lvl-1)); i++));
  do
    indent+=' '
  done  
  #echo -e "$indent" "${FUNCNAME[1]}" " End " "${BASH_LINENO[0]}" \("${FUNCNAME[2]}":"${BASH_LINENO[1]}"\)
  echo -e "$indent" "${FUNCNAME[1]}" " End " "${BASH_LINENO[0]}"
}

function get_pluglist () {
  Start "$*"  
  local error=0 now diff filedate
  if [ -f "$RACINE"/pluglist.json ]; then
    now=$(date +'%Y-%m-%d')
    filedate=$(stat "$RACINE"/pluglist.json | grep -E '^.*Modify:.*$' | cut -d ' ' -f 2)
    diff=$((($(date -d "$now" +%s) - $(date -d "$filedate" +%s))/86400))
    [ "$DEBUG" = true ] && info Diff days: $diff
    [[ "$diff" -lt "$DIFF_DAYS" ]] || wget download.moodle.org/api/1.3/pluglist.php -O "$RACINE"/pluglist.json
  else
    wget download.moodle.org/api/1.3/pluglist.php -O "$RACINE"/pluglist.json
  fi

  End
  return "$error"
}

function create_file () {

  if [ ! -f "$1" ];then
    touch "$1"
  fi
}

function create_dir () {
  error=0
  if [ ! -d "$1" ];then
    mkdir -p "$1"
  fi
}

function menu () {
  whiptail "$@" 3>&1 1>&2 2>&3 3>&-
  return "$?"
}

function is_project_branch () {
  cd "$MOODLE_SRC" || exit
  [[ $(git branch | grep "$PROJECT_BRANCH") ]] && return 0 || return 1
}


function is_official_plugin () {

  Start "$*"
  local error=0 plugin="$1"
  jq -r --arg plugin  "$plugin" '.plugins|map(select(.component == $plugin)) | .[]' "$RACINE"/pluglist.json > "$RACINE"/tmp.json
  
  [[ $(jq '.id' "$RACINE"/tmp.json) -gt 0 ]] || error=1
  
  End
  return "$error"
}

function is_moodleversion_supported () {

  # $1 PLUGIN
  # $2 moodle_version
  # out if PLUGIN supports moodle_version
  # VCS_URL
  # DOWNLOAD_URL

  Start "$*"
  local error=0 plugin="$1" moodle_version="$2" vcs download
  if is_official_plugin "$plugin"; then

    if jq -r '.versions[]| {(.version) : (.supportedmoodles[].release)}' "$RACINE"/tmp.json | 
      grep -E -o '([0-9]{10})": "'$moodle_version'"'| sort -nr| head -n 1; then
    
      vcs=$(jq -r '.versions[]|{(.supportedmoodles[].release) : .vcsrepositoryurl}' "$RACINE"/tmp.json | grep  -E -o '. *"'$moodle_version'":.*' | head -n 1) 
    
      if [[ "$vcs" =~ ^.*' "'(.*)'"'$ ]]; then
        VCS_URL="${BASH_REMATCH[1]}"
      else
        info no vcs url value  for specific version
      fi
    
      download=$(jq -r '.versions[]|{(.supportedmoodles[].release) : .downloadurl}' "$RACINE"/tmp.json | grep -E -o '.*"'$moodle_version'":.*' |  head -n 1) || true
      if [[ "$download" =~ ^.*' "'(.*)'"'$ ]]; then
        DOWNLOAD_URL="${BASH_REMATCH[1]}"
      else
        DOWNLOAD_URL=null
        error no value for vcs or download url
        error=1
      fi

    else
      error "$plugin" no specific version "$moodle_version"
      error=1
    fi
  else
    error "$plugin" not official plugin 
    error=1
  fi

  End
  return "$error"
}

function is_moodleversion_supported.old () {
  # $1 PLUGIN
  # $2 moodle_version
  # out if PLUGIN supports moodle_version
  # VCS_URL
  # DOWNLOAD_URL
  Start "$*"
  local error=0 plugin="$1" moodle_version="$2" vcs download plugin_min_version plugin_max_version
  
  VCS_URL=null
  DOWNLOAD_URL=null
      
  if is_official_plugin "$plugin"; then    
    
    plugin_min_version=$(jq -r '.versions[].supportedmoodles[].release' "$RACINE"/tmp.json | sort  | head -n 1) || true
    plugin_max_version=$(jq -r '.versions[].supportedmoodles[].release' "$RACINE"/tmp.json | sort -rn | head -n 1) || true
    info "$plugin" Moodle version supported Min: "$plugin_min_version" Max: "$plugin_max_version"
    
    PLUGIN_MOODLE_VERSION=$(jq -r '.versions[]| {(.version) : (.supportedmoodles[].release)}' "$RACINE"/tmp.json | 
    grep -E -o '([0-9]{10})": "'$moodle_version'"'| sort -nr| head -n 1) || true
    #grep ': '"$moodle_version" | sort -nr | grep -E -o  "([0-9]{10})" | head -n 1)
    [[ -n "$PLUGIN_MOODLE_VERSION" ]] && info "$plugin": "$moodle_version" supported || { error "$plugin" no specific version "$moodle_version"; error=1; }
    if [[ $error -eq 0 ]]; then
      vcs=$(jq -r '.versions[]|{(.supportedmoodles[].release) : .vcsrepositoryurl}' "$RACINE"/tmp.json | grep  -E -o '.*"'$moodle_version'":.*' | head -n 1) || true      
      if [[ "$vcs" =~ ^.*' "'(.*)'"'$ ]]; then
        VCS_URL="${BASH_REMATCH[1]}"
      else
        info no vcs url value  for specific version
      fi
      
      download=$(jq -r '.versions[]|{(.supportedmoodles[].release) : .downloadurl}' "$RACINE"/tmp.json | grep -E -o '.*"'$moodle_version'":.*' |  head -n 1) || true
      if [[ "$download" =~ ^.*' "'(.*)'"'$ ]]; then
        DOWNLOAD_URL="${BASH_REMATCH[1]}"
      else
        DOWNLOAD_URL=null
        error no value for vcs or download url
        error=1
      fi
    fi
  else
    error "$plugin"  not in official repository
    error=1
  fi

  [ "$DEBUG" = true ] && info vcs "$vcs" download: "$download"
  [ "$DEBUG" = true ] && info VCS URL: "$VCS_URL" DOWNLOAD URL: "$DOWNLOAD_URL"
  [ "$DEBUG" = true ] && info error: "$error"
  End
  return "$error"
}

function get_project_conf () {
  # $1 : PROJECT
  Start "$*"

  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ] || { error Project "$PROJECT" not exists; return 1; }
  jq . "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json >/dev/null  || { error invalid config file; return 1; }

  PROJECT_BRANCH=$(jq -r .project.branch "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  PROJECT_MOODLE_VERSION=$(jq -r .moodle.version "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  MOODLE_VERSION="${PROJECT_MOODLE_VERSION:0:3}"
  MOODLE_BRANCH=$(jq -r '."'${MOODLE_VERSION}'".branch' "$RACINE"/moodle-versions.json)

  [ "$DEBUG" = true ] && info PROJECT_BRANCH: "$PROJECT_BRANCH"
  [ "$DEBUG" = true ] && info PROJECT_MOODLE_VERSION: "$PROJECT_MOODLE_VERSION"
  [ "$DEBUG" = true ] && info MOODLE_VERSION: "$MOODLE_VERSION"
  [ "$DEBUG" = true ] && info MOODLE_BRANCH: "$MOODLE_BRANCH"

  End
  return
}


function is_moodle_version_valid () {

  # IN $1 project_moodle_version
  # OUT return 0 if success else return 1
  #     $MOODLE_VERSION
  #     $MOODLE_BRANCH
  # valid version
  # 5.0 last tag version tag : 5.0.4
  # 5.0+ last version in branch
  # 5.0.3 version defined with tag

  Start "$*"
  local error=0 project_moodle_version="$1"
  #$(jq -r .moodle.version "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  
  if [[ "$project_moodle_version" =~ ^[4-5]\.[0-5]\+?|^[4-5]\.[0-5]\.[0-9]$ ]]; then
    MOODLE_VERSION="${project_moodle_version:0:3}"
    [ "$DEBUG" = true ] && info MOODLE_VERSION: "$MOODLE_VERSION"
  # la branche de la version MOODLE majeure est obtenue par moodle-version.json
    MOODLE_BRANCH=$(jq -r '."'${MOODLE_VERSION}'".branch' "$RACINE"/moodle-versions.json)
    [ "$DEBUG" = true ] && info MOODLE_BRANCH: "$MOODLE_BRANCH"
    if [[ "$MOODLE_BRANCH" != null  ]]; then
      [ "$DEBUG" = true ] && info "Moodle: $MOODLE_VERSION Branch: $MOODLE_BRANCH"
    else
      error "Version ${MOODLE_VERSION} unknown"
      error=1
    fi
  else
    # on doit tester si |^[a-f0-9]{7,40} !
    error "Version ${MOODLE_VERSION} unknown"
    error=1
  fi

  End
  return $error
}

function create_commit.old () {

  cd "$PROJECTS_PATH" || exit
  if [[ $(git status --porcelain) ]]; then
    if [ -z "$1" ]; then
      error commit message undefined
      exit
    else
      git add .
      git commit -m "$1"
    fi
  fi
}

function get_moodle_desired_state () {
  Start "$*"
  # get project requested state
  # PARAM IN  : $1 project
  #       OUT :
  #             PROJECT_MOODLE_VERSION (from <project>.json)
  #             MOODLE_VERSION
  #             MOODLE_BRANCH
  #             MOODLE_DESIRED_STATE (as commit if MOODLE_SRC exists)
  local error=0 project="$1"

  MOODLE_DESIRED_STATE=''

  if [[ -d "$MOODLE_SRC" ]]; then
    cd "$MOODLE_SRC" || exit
    if [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-5]$ ]]; then
    #for example 4.5
      [ "$DEBUG" = true ] && info "Latest available release $PROJECT_MOODLE_VERSION"
      echo "latest available release $PROJECT_MOODLE_VERSION"
      git checkout "$MOODLE_BRANCH" --quiet
      tags=$(git tag -l v"$PROJECT_MOODLE_VERSION"*)
      [ -z "$tags" ] && error Tags are missing!  && return 1
      [ "$DEBUG" = true ] && info Tags: "$tags"
      MOODLE_DESIRED_STATE=v${tags##*v}
      [ "$DEBUG" = true ] && info MOODLE_DESIRED_STATE: "$MOODLE_DESIRED_STATE"
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-5]\+$ ]]; then
      #for example 4.5+
      git checkout "$MOODLE_BRANCH" --quiet
      MOODLE_DESIRED_STATE="$MOODLE_BRANCH"
      [ "$DEBUG" = true ] && info Latest available release "$PROJECT_MOODLE_VERSION" with fixes: "MOODLE_DESIRED_STATE"
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-5]\.[0-9]$ ]]; then
      #for example 4.5.1
      git checkout "$MOODLE_BRANCH" --quiet
      [[ $(git tag -l "v${PROJECT_MOODLE_VERSION}") ]] || (error "Release $PROJECT_MOODLE_VERSION not exists" && return 1)
      MOODLE_DESIRED_STATE=v$PROJECT_MOODLE_VERSION
      [ "$DEBUG" = true ] && info Specific release in "$PROJECT_MOODLE_VERSION" : "MOODLE_DESIRED_STATE"
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[4-5]\.[0-5]\.[0-9]?\+$ ]]; then
      error Specific release with fixes in "$PROJECT_MOODLE_VERSION" not yet supported...
      error=1
    elif [[ "$PROJECT_MOODLE_VERSION" =~ ^[a-f0-9]{7,40}$ ]]; then
      [ "$DEBUG" = true ] && info "force commit $PROJECT_MOODLE_VERSION"
      local branch
      branch=$(git branch --contains "$PROJECT_MOODLE_VERSION")
      if [[ "$branch" =~ ^.*(MOODLE_[0-9]{2,3}_STABLE).*$ ]]; then
        [ "$DEBUG" = true ] && info Commit "$PROJECT_MOODLE_VERSION" branch found: "${BASH_REMATCH[1]}"
         MOODLE_BRANCH="${BASH_REMATCH[1]}"
         MOODLE_DESIRED_STATE="$PROJECT_MOODLE_VERSION"
      else
        error no branch MOODLE_XXX_STABLE found
        error=1
      fi
    else
      error Moodle version nothing found
      error=1
    fi
  else
  # current when no MOODLE repo
    warn Moodle source repository not present
    error=1
  fi

  if [[ -d "$MOODLE_SRC" ]]; then
    info git checkout "$MOODLE_DESIRED_STATE"
    git checkout "$MOODLE_DESIRED_STATE" --quiet
    CURRENT_STATE=$(git rev-parse --short HEAD)
  fi

  [ "$DEBUG" = true ] && info PROJECT_MOODLE_VERSION: "$PROJECT_MOODLE_VERSION"
  [ "$DEBUG" = true ] && info MOODLE_VERSION: "${MOODLE_VERSION:-}"
  [ "$DEBUG" = true ] && info MOODLE_BRANCH: "$MOODLE_BRANCH"
  [ "$DEBUG" = true ] && info MOODLE_DESIRED_STATE: "$MOODLE_DESIRED_STATE"
  [ "$DEBUG" = true ] && info CURRENT_STATE: "${CURRENT_STATE:-}"

  End
  return "$error"
}

function repo_need_upgrade () {
  # 1 repository
  # 2 branch
  Start "$*"
  local error=0 repo="$1" branch="$2" local remote base base
  
  [ "$DEBUG" = true ]&& info repo: "$repo" branch: "$branch"

  cd "$repo" || exit
  git checkout "$branch" --quiet

  git remote | grep upstream >/dev/null || { error no remote upstring; return 2; }

  local=$(git rev-parse @)
  remote=$(git rev-parse @{u})
  base=$(git merge-base @ @{u})

  [ "$DEBUG" = true ]&& info local:  " ${local:0:7}"
  [ "$DEBUG" = true ]&& info remote: "${remote:0:7}"
  [ "$DEBUG" = true ]&& info base:   "  ${base:0:7}"

  if [ "$local" = "$remote" ]; then
    success "$repo branche $branch up-to-date with branch remote"
    error=0
  elif [ "$local" = "$base" ]; then
    warn "$repo branche $branch need to pull from remote"
    error=1
  elif [ "$remote" == "$base" ]; then
    warn "$repo branche $branch need to push to remote"
    error=3
  else
    error "$repo branche $branch diverged with remote"
    error=4
  fi

  End
  return "$error"

}

function config_check () {

# 1 PROJECT

  Start "$*"
  local error=0

  # check PROJECT_MOODLE_VERSION
  get_project_conf "$PROJECT" || error=1
  # is up to date

  get_plugins "$PROJECT"
  for plugin in "${PLUGINS[@]}"; do
    info "Check plugin: $plugin"
    is_moodleversion_supported "$plugin" "$MOODLE_VERSION" || error=1
  done

  End
  return "$error"
}

function is_plugin_branch () {
# 1 PLUGIN
# 2 branch
# check if exists upstream/"$2"
  if [[ -n $(git rev-parse --verify upstream/"$2" 2>/dev/null) ]]; then
    git checkout "$2" --quiet || git branch "$2" upstream/"$2"
    info plugin branch "$2" selected for "$1"
    return 0
  else
    return 1
  fi
}

function create_project () {

  # 1 Project
  # 2 Project Moodle version

  Start "$*"
  local error=0

  [ -d "$PROJECTS_PATH"/"$1" ] && error Project "$1" already exists && return 1
  #create_dirs
  create_dir "$PROJECTS_PATH"
  create_dir "$PLUGINS_REPO"
  create_dir "$PROJECTS_PATH"/"$1"
  create_file "$PROJECTS_PATH"/"$1"/"$1".json

  PROJECT="$1"
  PROJECT_BRANCH="$PROJECT"
  PROJECT_MOODLE_VERSION="$2"
  if is_moodle_version_valid "$PROJECT_MOODLE_VERSION"; then
    sed -e "s/\${project}/$PROJECT/" -e "s/\${version}/$PROJECT_MOODLE_VERSION/" "$RACINE"/template > "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json

    if [ -d "$MOODLE_SRC" ]; then
      cd "$MOODLE_SRC" || exit
      info "$MOODLE_SRC" already exists
      git fetch upstream --tags --quiet
      if [[ $(git branch --list | grep "^.*$MOODLE_BRANCH") ]]; then
        info "Branch $MOODLE_BRANCH exists, update if necessary"
        git switch "$MOODLE_BRANCH" --quiet
        git merge --ff-only  upstream/"$MOODLE_BRANCH" --quiet
      else 
        info "Branch $MOODLE_BRANCH not exists create branch"
        git branch "$MOODLE_BRANCH" remotes/upstream/"$MOODLE_BRANCH"
        # git remote set-branches upstream "$MOODLE_BRANCH" || check_command "error git remote set-branches upstream $MOODLE_BRANCH"
        #git fetch upstream "$MOODLE_BRANCH" --tags --quiet || check_command "error git fetch upstream $MOODLE_BRANCH --tags --quiet"
      # else
      #   update_moodle "$PROJECT"
      fi
    else
      info "$MOODLE_SRC" does not exists
      if [[ "$DEPTH" -gt 0 ]]; then
        git clone --branch "$MOODLE_BRANCH" --depth "$DEPTH" "$MOODLE_DEPOT"  "$MOODLE_SRC"
      else
        git clone --branch "$MOODLE_BRANCH" "$MOODLE_DEPOT"  "$MOODLE_SRC"
      fi
      cd "$MOODLE_SRC" || exit
      git remote add upstream "$MOODLE_HQ"
    fi
    
    if get_moodle_desired_state "$PROJECT"; then
      # Create project branch
      cd "$MOODLE_SRC" || exit
      git checkout "$MOODLE_DESIRED_STATE" --quiet
      git branch "$PROJECT_BRANCH" "$MOODLE_DESIRED_STATE"
      info Branch "$PROJECT_BRANCH" from "$MOODLE_DESIRED_STATE" created
      git checkout "$PROJECT_BRANCH" --quiet
    else
      error "$?" get Moodle desired state
      error=1
    fi
   

    # info PROJECT_BRANCH: "$PROJECT_BRANCH"
      
    # if [[ $(git show-ref refs/heads/"$PROJECT_BRANCH") ]]; then
    #   git checkout  "$PROJECT_BRANCH" --quiet
    # else 
    #   git checkout -b "$PROJECT_BRANCH" --quiet
    # fi
  
    # git merge "$MOODLE_BRANCH"
    # success "$PROJECT_BRANCH" merged after Moodle update
  

  else
    error Moodle Version "$PROJECT_VERSION" invalid
    error=1
  fi

End
  return "$error"

}

function update_moodle () {
  Start "$*"
  local error=0

  cd "$MOODLE_SRC" || exit
  git fetch upstream
  git checkout "$MOODLE_BRANCH" --quiet
  git merge --ff-only  upstream/"$MOODLE_BRANCH" --quiet

  get_moodle_desired_state "$PROJECT" || { error "$1";return 1; }
  info merge "$PROJECT_BRANCH" "$MOODLE_DESIRED_STATE"
  cd "$MOODLE_SRC" || exit 1   
  git checkout "$PROJECT_BRANCH" --quiet
  git merge "$MOODLE_DESIRED_STATE" --quiet
  
  End
  return "$error"

}

function list_plugins_cache () {
  Start "$*"
  local error=0 
  # i=0 list=''
  # for d in $(ls -l "$PLUGINS_REPO" | awk '{print $9}' | sort);
  # do
  #   i=$((i+1))
  #   list="$list $d"
  # done

  # menu --title "Plugins cache" --checklist "Plugin's List(cache)" 25 78 16 $list || true
  # count plugins and compute windows height 
  h=$(($(find "$PLUGINS_REPO" -maxdepth 1 -type d -print| wc -l)*28))
  [ "$DEBUG" = true ]&& info height plugins window "$h" 
  [ "$h" -gt 672 ]&& h=672
  zenity --list --height="$h" --column=Plugin $(ls -1 "$PLUGINS_REPO")
  error="$?"
  End
  return "$error"
}

function get_plugin_dir () {
  # IN: $PLUGIN  (type_component name)
  # OUT: $DIR
  Start "$*"
  error=0
  # le fichier components.json permet de determiner le repertoire de destination a partir du type de plugin
  # pour convertir au format yaml : jq -oy components.json > components.json
  #https://blog.kiprosh.com/regular-expressions-greedy-vs-non-greedy/ type_stype_name
  # doesn t works wit bash !
  # if plugin type valid DIR is set
  local ss error
  error=0
  if [[ "$1" =~ ^[a-z].*?_.*$ ]];
  then
    PLUGIN="$1"
    ss=${1#*-}
    COMPONENT_NAME=${1#*_}
    TYPE=${ss%%_*}
    DIR=$(jq -r .plugintypes."$TYPE" "$RACINE"/types.json)
    [ "$DEBUG" = true ] && info PLUGIN: "$PLUGIN"
    [ "$DEBUG" = true ] && info TYPE: "$TYPE"
    [ "$DEBUG" = true ] && info COMPONENT_NAME: "$COMPONENT_NAME"
    [ "$DEBUG" = true ] && info DIR: "$DIR"
    [ "$DIR" == null ] && error type: "$TYPE" invalide && error=1
  else
    error=1
    error Incorrect plugin syntax "$1"
  fi
  End
  return "$error"

}

function add_plugin_cache () {

  Start "$*"
  local error=0 valid_plugin=1
  while [ "$valid_plugin" -ne 0 ]; do
    #parm=$(menu --inputbox "New plugin (type_name) ?" 8 39 "" --title "Add plugin")
    # en parametre le plugin recherché sous la forme <type>_<name>
    parm=$(zenity --entry --text "New plugin?" --entry-text "<type>_<name>" --title "Code Base Manager")
    error="$?"
    if [[ "$error" -eq 0 && -n "$parm" ]]; then
      PLUGIN="$parm"
      valid_plugin=0
      info plugin: "$parm"
    #  [ -z "$parm" ] && error "$parm" Parametre plugin missing && valid_plugin=1
    else
      error No plugin selected or Cancel
      return "$error"
    fi
  done

  if [ -d "$PLUGINS_REPO"/"$PLUGIN" ]; then
    warn "$PLUGIN" already exists
  else
    get_plugin_dir "$parm" && { PLUGIN="$parm"; valid_plugin=0; } || valid_plugin=1
      [ "$DEBUG" = true ] && info plugin: "$PLUGIN" "$TYPE" "$COMPONENT_NAME"
      # Recherche dans le fichier de référence des plugins
      # Add plugin
    if is_moodleversion_supported "$PLUGIN" "$MOODLE_VERSION"; then
        if [[ "VCS_URL" != null ]]; then
          info Plugin Source : "$VCS_URL"
          clone_plugin "$PLUGIN" "$VCS_URL"
          success "$PLUGIN locally loaded in cache"
        else
          error "$PLUGIN" not loaded in cache
        fi
    else
        error plugin "$PLUGIN" not found in official plugins directory
        error=0
    fi
  fi
  End
  return "$error"
}

function clone_plugin () {
  # 1 PLUGIN
  # 2 url source
  Start "$*"
  if [ ! -d "$PLUGINS_REPO"/"$PLUGIN" ];
  then
    cd "$PLUGINS_REPO" || exit
    git clone "$2" "$1" --quiet
    cd "$PLUGINS_REPO"/"$1" || exit
    git remote rename origin upstream
  fi
  End

}

function edit_plugins () {
info
  Start "$*"
  error=0

  get_moodle_desired_state "$PROJECT"
  local date_before date_after
  date_before=$(date -r "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  get_plugins "$PROJECT"
  plugins_before="$PLUGINS"

  ret=1
  while [ $ret -ne 0 ];
  do
  # exec {STDOUTBACK}>&1
  # exec {STDERRBACK}>&2
  # exec 1>>/dev/pts/0
  # exec 2>>/dev/pts/0
  nano "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
  ret="$?"
  # exec 1>&$STDOUTBACK
  # exec 2>&$STDERRBACK

  # config_check && ret=0 || wait_keyboard 'Error in config file.Press any key and correct'
  done

  date_after=$(date -r "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  if [ "$date_after" != "$date_before" ]; then
     [ "$DEBUG" = true ] && echo "il y a eu des maj..."
    # check validity .json
    jq "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json >/dev/null || exit 1
    get_plugins "$PROJECT"
    plugins_after="${PLUGINS[@]}"

    # on ne récupere que les plugins uniques donc uniquement ceux supprimés et non aussi ceux ajoutés !
    plugins_suppress=$(echo "$plugins_before" "$plugins_after" "$plugins_after" | tr ' ' '\n' | sort | uniq -u)

    if [ -n "$plugins_suppress" ]; then
      for key in "${!plugins_suppress[@]}"; do
        # skip first entry -[ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ]
        [[ ${plugins_suppress[$key]} == '-' ]] && continue
        echo "A supprimmer: $key ${plugins_suppress[$key]}"
        suppress_plugin "${plugins_suppress[$key]}"
      done
      #create_commit "Update edit_plugins"
      must_update_codebase=1
    fi
  else
    [ "$DEBUG" = true ] && info "Pas de modification de la liste des plugins"
  fi
  if [ -n "${must_update_codebase:-}" ] && [ "$must_update_codebase" -eq 1 ]; then
    update_codebase "$PROJECT"
    success Code base updated
  fi
  End
  return "$error"
}

function get_plugins () {

  #in: $project
  #out: $PLUGINS

  Start "$*"
  local project="$1"
  if [[ $(jq '.plugins' "$PROJECTS_PATH"/"$project"/"$project".json) != null ]]; then
    PLUGINS=($(jq -r ".plugins[].name" "$PROJECTS_PATH"/"$project"/"$project".json | tr "\n" " "))
  else
    PLUGINS=()
    warn plugins list empty
  fi
  [ "$DEBUG" = true ] && info Nb plugins: "${#PLUGINS[@]}"

  End
}

function update_plugins_repo () {

  Start "$*"
  error=0
  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ]

  get_plugins "$PROJECT"

  for PLUGIN in "${PLUGINS[@]}"; do
    [ "$DEBUG" = true ] && info check PLUGIN: "$PLUGIN"
    if [ -d "$PLUGINS_REPO"/"$PLUGIN" ]; then
      get_plugin_desired_state "$PLUGIN" "$MOODLE_VERSION"
      repo_need_upgrade "$PLUGINS_REPO"/"$PLUGIN" "$PLUGIN_BRANCH" && ret="$?" || ret="$?"
      case "$ret" in
      0)
        success "$PLUGIN" up to date
        error=0
        ;;
      1)
        info "Mise à jour automatique du plugin $PLUGIN" from upstream
        git checkout --quiet "$PLUGIN_BRANCH"
        git merge --quiet --ff-only upstream/"$PLUGIN_BRANCH"

        if [ "$LOCALDEV" != null ];
        then
          # EXISTS=$(git show-ref refs/heads/"$LOCALDEV")          
          # if [[ -z $EXISTS ]]; then
          #   git branch --quiet "$LOCALDEV"
          # fi
          git show-ref refs/heads/"$LOCALDEV" 1>/dev/null && git checkout -b --quiet "$LOCALDEV" || git checkout --quiet "$LOCALDEV"
          git checkout --quiet "$LOCALDEV"
          git rebase --quiet "$PLUGIN_BRANCH"
        fi
        error=0
        ;;
      2)
        warn "$PLUGIN" no remote repo found
        error=0
        ;;
      3)
        warn "$PLUGIN_BRANCH need to push to remote"
        error=1
        ;;
      4)
        error "$PLUGIN_BRANCH diverged with remote"
        error=1
        ;;
      esac
    else
      error "$PLUGIN" missing in local cache
      error=1
    fi
  done

  End
  return "$error"

}

function get_plugin_desired_state () {

  Start "$*"
  local error=0
  PLUGIN="$1"
  MOODLE_VERSION="$2"

  # returned parameters from <project>.json

  # VERSION (tag)
  # BRANCH
  # VERSIONNUMBER  yyyymmddxx

  [ -d "$PLUGINS_REPO"/"$PLUGIN" ] || { error Plugin "$PLUGIN" not present in cache; return 1; }

  if get_plugin_project_state "$PLUGIN" "$MOODLE_VERSION" ; then
     info values from project file 
  else
     get_plugin_default_state "$PLUGIN" "$MOODLE_VERSION" && error="$?"|| error="$?"      
     info values from plugin 
  fi

  [ "$DEBUG" = true ] && info "$error" "  PLUGIN_STATE_TYPE: $PLUGIN_STATE_TYPE" PLUGIN_DESIRED_STATE: "$PLUGIN_DESIRED_STATE"
  
  End
  return "$error"

}

function get_plugin_project_state () {

  Start "$*"
  # 1 PLUGIN
  PLUGIN="$1"
  MOODLE_VERSION="$2"
  local error=0 plugin_branch plugin_versionnumber plugin_version
  
  PLUGIN_STATE_TYPE=null
  PLUGIN_DESIRED_STATE=null

  plugin_branch=$(jq --arg plugin "$PLUGIN" -r '.plugins[]|select(.name==$plugin).branch' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  plugin_versionnumber=$(jq --arg plugin "$PLUGIN" -r '.plugins[]| select(.name==$plugin).versionnumber' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  plugin_version=$(jq --arg plugin "$PLUGIN" -r '.plugins[]|select(.name==$plugin).version' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json)
  [ "$DEBUG" == true ]&& info plugin_branch: "$plugin_branch" plugin_versionnumber: "$plugin_versionnumber" plugin_version: "$plugin_version"
  if [[ "$plugin_version" != null ]]; then
    PLUGIN_STATE_TYPE=version
    PLUGIN_DESIRED_STATE="$plugin_version"

  elif [[ "$plugin_branch" != null ]]; then
    PLUGIN_STATE_TYPE=branch
    PLUGIN_DESIRED_STATE="$plugin_branch"

  elif [[ "$plugin_versionnumber" != null ]]; then
    PLUGIN_STATE_TYPE=versionnumber
    PLUGIN_DESIRED_STATE="$plugin_versionnumber"
  else
    info no value for "$PLUGIN" in "$PROJECT".json
    error=1
  fi

  End
  return "$error"

}


function get_plugin_default_state () {

  Start "$*"
  PLUGIN="$1"
  MOODLE_VERSION="$2"
  local error=0 vcstag downloadurl
  PLUGIN_STATE_TYPE=null
  PLUGIN_DESIRED_STATE=null
  if is_moodleversion_supported "$PLUGIN" "$MOODLE_VERSION" ; then
    vcstag=$(jq -r --arg moodle_version "$MOODLE_VERSION" '[.versions[]| {version: .vcstag, moodle: .supportedmoodles[].release}]|.[]|select(.moodle == $moodle_version)|.version' "$RACINE"/tmp.json | sort -rn | head -n 1)
    info vcstag: "$vcstag"
    if [[ "$vcstag" != null ]]; then
      [ "$DEBUG" = true ] && info Tag: "$vcstag"
      PLUGIN_STATE_TYPE=vcstag
      PLUGIN_DESIRED_STATE="$vcstag"
    else
      downloadurl=$(jq -r --arg moodle_version "$MOODLE_VERSION" '[.versions[]| {version: .downloadurl, moodle: .supportedmoodles[].release}]|.[]|select(.moodle == $moodle_version)|.version' "$RACINE"/tmp.json | sort -rn | head -n 1)
      if [[ "$downloadurl" != null ]]; then
        [ "$DEBUG" = true ] && info DOWNLOADURL: "$DOWNLOADURL"
        PLUGIN_STATE_TYPE=versionnumber
        PLUGIN_DESIRED_STATE="$downloadurl"
      else
        error "$PLUGIN" no vcstag or downloadurl
        error=1
      fi
    fi
  else
    error "$PLUGIN" not supports Moodle version "$MOODLE_VERSION"
    error=1
  fi
  [ "$DEBUG" = true ] && info Plugin: "$PLUGIN" default state: "$PLUGIN_STATE_TYPE" desired state: "$PLUGIN_DESIRED_STATE"

  End
  return "$error"

}
function get_observed_state () {
   Start "$*"
  local error=0 plugin="$1"
   
  OBSERVED_TYPE=null
  OBSERVED_STATE=null

  get_plugin_dir "$plugin" "$plugin"
    
  if [[ -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]]; then
    cd "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" || exit
    [[ $(grep .gitrepo -e 'PLUGIN_STATE_TYPE=') =~ ^.*PLUGIN_STATE_TYPE=(.*)$ ]] &&   OBSERVED_TYPE="${BASH_REMATCH[1]}" || error=1
    [[ $(grep .gitrepo -e 'PLUGIN_DESIRED_STATE=') =~ ^.*PLUGIN_DESIRED_STATE=(.*)$ ]] && OBSERVED_STATE="${BASH_REMATCH[1]}" || error=1
  fi
  [ "$DEBUG" = true ] && info "$PLUGIN" observed type : "$OBSERVED_TYPE" state: "$OBSERVED_STATE"
  End
  return "$error"
}

function codebase_need_update () {

  Start "$*"
  local error=0 plugin="$1"
  if get_plugin_desired_state "$plugin" "$MOODLE_VERSION"; then
    info state: "$plugin" : "$PLUGIN_STATE_TYPE" : "$PLUGIN_DESIRED_STATE"
    
    get_observed_state "$PLUGIN" || true
    if [ "$PLUGIN_STATE_TYPE" == "$OBSERVED_TYPE" ] && [ "$PLUGIN_DESIRED_STATE" == "$OBSERVED_STATE" ]; then
      success "$PLUGIN" type "$PLUGIN_STATE_TYPE" state "$PLUGIN_DESIRED_STATE" already synchronized
    else
      install_plugin_project "$plugin" "$PLUGIN_STATE_TYPE" "$PLUGIN_DESIRED_STATE"
    fi    
  else
    error "$PLUGIN" no desired state defined. no install
  fi

  End
  return "$error"
}

function install_plugin_project ()  {
  # install plugin (add or update)
  Start "$*"
  local error=0 
  PLUGIN="$1"
  PLUGIN_STATE_TYPE="$2"
  PLUGIN_DESIRED_STATE="$3"

  [ "$DEBUG" == true ] && info PLUGIN_STATE_TYPE: "$PLUGIN_STATE_TYPE" PLUGIN_DESIRED_STATE: "$PLUGIN_DESIRED_STATE"

  case "$PLUGIN_STATE_TYPE" in
  "version")
    info PLUGIN_STATE_TYPE "$PLUGIN_STATE_TYPE";;
  "branch")
    info PLUGIN_STATE_TYPE "$PLUGIN_STATE_TYPE";;
  "versionnumber")
    install_plugin_versionnumber "$PLUGIN" "Add $PLUGIN" "$PLUGIN_STATE_TYPE" "$PLUGIN_DESIRED_STATE";;
  "vcstag")
    install_plugin_vcstag "$PLUGIN" "Add $PLUGIN" "$PLUGIN_STATE_TYPE" "$PLUGIN_DESIRED_STATE";;
  *)
    error Unknown PLUGIN_STATE_TYPE "$PLUGIN_STATE_TYPE";;
  esac

  End
  return "$error"
}

function install_plugin_vcstag () {

  Start "$*"
  local error=0
  PLUGIN="$1"
  MSG="$2"
  PLUGIN_STATE_TYPE="$3"
  PLUGIN_DESIRED_STATE="$4"
  
  [ "$DEBUG" == true ] && info "$1" "$2" "$3" "$4"

  [ -d "$PLUGINS_REPO"/"$PLUGIN" ] || { error "$PLUGIN" not in cache; exit; }
  cd "$PLUGINS_REPO"/"$PLUGIN" || exit
  git checkout "$PLUGIN_DESIRED_STATE" --quiet

  cd "$MOODLE_SRC" || exit
  git checkout "$PROJECT_BRANCH" --quiet

  get_plugin_dir "$PLUGIN"

  if [ ! -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]; then
    mkdir -p "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"
  fi
  rsync -a --delete --exclude '.git' "$PLUGINS_REPO"/"$PLUGIN/" "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME/"

  echo "    PLUGIN_STATE_TYPE=$PLUGIN_STATE_TYPE" > "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo
  echo "    PLUGIN_DESIRED_STATE=$PLUGIN_DESIRED_STATE" >> "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo
  git add .
  git commit -m "$MSG" --quiet

  End
  return "$error"

}

function install_plugin_versionnumber () {

  Start "$*"
  local error=0 TYPE
  PLUGIN="$1"
  MSG="$2"
  PLUGIN_STATE_TYPE="$3"
  DOWNLOADURL="$4"

  get_plugin_dir "$PLUGIN"
  [ "$DEBUG" == true ] && info "PLUGIN" dir: "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"

  if [[ -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]]; then

    cd "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" || exit
    [[ $(grep .gitrepo -e 'PLUGIN_STATE_TYPE=') =~ ^.*PLUGIN_TYPE=(.*)$ ]] && TYPE="${BASH_REMATCH[1]}"
  else
    mkdir -p "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"
    cd "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" || exit
    info download url : "$DOWNLOADURL"
    curl "$DOWNLOADURL" -o tmp.zip
    [ "$DEBUG" == true ] && info unzip tmp.zip onto "$MOODLE_SRC"/"$DIR"
    unzip  tmp.zip -d  "$MOODLE_SRC"/"$DIR"/  && rm tmp.zip
    info before Commit Add plugin "PLUGIN" in "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"
    echo "    PLUGIN_STATE_TYPE=$PLUGIN_STATE_TYPE" > "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo
    echo "    PLUGIN_DESIRED_STATE=$PLUGIN_DESIRED_STATE" >> "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo
    git add "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"
    git commit -m "Add plugin $PLUGIN"

  fi
}

function update_codebase () {
  Start "$*"
  local error=0 plugin

  get_plugins "$PROJECT"

  for plugin in "${PLUGINS[@]}"
  do
    info plugin: "$plugin"
    codebase_need_update "$plugin" "$MOODLE_VERSION"
  done
  End
}

function release () {

Start "$*"
error=0
[ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ]

# $1 MSG for new release

NEWRELEASE="$PROJECT_BRANCH"-$(date +%Y.%m.%d@%Hh%M)
MSG="${1:-$NEWRELEASE}"

info MSG: "$MSG"
cd "$MOODLE_SRC" || exit
[ "$DEBUG" = true ] && info PROJECT_BRANCH: "$PROJECT_BRANCH"
git checkout "$PROJECT_BRANCH" --quiet
git commit --allow-empty -m "$MSG"
git tag -a "$NEWRELEASE" -m ""

# create <PROJECT>.lock
project_lock "$NEWRELEASE"

cd "$MOODLE_SRC" || exit
git checkout "$PROJECT_BRANCH" --quiet

  if [  -n "${MOODLE_UPDATE_ORIGIN:-}" ]; then
    [ "$DEBUG" = true ] && info MOODLE_UPDATE_ORIGIN: "$MOODLE_UPDATE_ORIGIN"
    remote_origin_url=$(git config remote.origin.url)
    [ "$DEBUG" = true ] && info remote_origin_url: "$remote_origin_url"
    if [ -n "$remote_origin_url" ]; then
      if [ "$remote_origin_url" == "$MOODLE_UPDATE_ORIGIN" ]; then
        git push origin "$PROJECT_BRANCH"
        success "$MOODLE_UPDATE_ORIGIN" successfully updated
      else
        error remote url has changed : "$remote_origin_url"
        error=1
        exit
      fi
    else
      # first time not configured
      info First time configure git add remote origin "$MOODLE_UPDATE_ORIGIN"
      git remote add origin "$MOODLE_UPDATE_ORIGIN"
      success remote add origin "$MOODLE_UPDATE_ORIGIN"
      # The option -u is for “set upstream”.
      #It configures the local branch to track the remote branch.
      # You dont need to use it more than once.
      git push -u origin "$PROJECT_BRANCH"
      success "$MOODLE_UPDATE_ORIGIN" updated
    fi
  fi


End
return "$error"

}

function project_lock () {

  local error=0 common_ancestor
  Start "$*"

  NEWRELEASE="${1}"
  error=0
  cd "$PROJECTS_PATH"/"$PROJECT" || exit
  # create "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json ] || exit
  [ -f "$PROJECT".lock ] && rm "$PROJECT".lock
  cp "$PROJECT".json "$PROJECT".lock

  [ "$DEBUG" = true ] && info PROJECT_BRANCH: "$PROJECT_BRANCH" Moodle: "$MOODLE_BRANCH"

  cd "$MOODLE_SRC" || exit
  git checkout "$PROJECT_BRANCH" --quiet
  info MOODLE_BRANCH "$MOODLE_BRANCH"
  jq --arg moodle_branch "$MOODLE_BRANCH" '.moodle.branch=$moodle_branch' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock > "$PROJECT".tmp
  mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  common_ancestor=$(git merge-base  "$PROJECT_BRANCH" "$MOODLE_BRANCH"  )
  jq --arg moodleversion "${common_ancestor:0:7}" '.moodle.version=$moodleversion' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock > "$PROJECT".tmp
  mv -- "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock

  get_plugins "$PROJECT"
  for PLUGIN in "${PLUGINS[@]}"; do
    [ "$DEBUG" = true ] &&info "Add lock metadata plugin: $PLUGIN"
    get_plugin_dir "$PLUGIN"
    if [[ -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]]; then
      if [[ $(grep 'PLUGIN_STATE_TYPE' < "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME"/.gitrepo) =~ ^.*=(.*)$ ]]; then
          jq --arg name "$PLUGIN" --arg type "${BASH_REMATCH[1]}" \
        '(.plugins[]|select(.name==$name)).type=$type' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock > "$PROJECT".tmp
        mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
      else
        error content type not found  "$PLUGIN"/.gitrepo
      fi
    else
      warn "$PLUGIN" not installed
    fi

  done

  #create_commit "$NEWRELEASE"
  End "$PROJECT"
  return $error
}

function rm_plugin () {
  Start "$*"
  local error=0 list='' n=0

  list=$(jq -r '.plugins[].name | "FALSE "+.' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json | tr  '\n' ' ')
  PLUGIN=$(zenity --list --radiolist --text "Suppress plugin from project $PROJECT" --title "Code Base Manager" \
     --column Use --column Plugin $list)

  [[ "$?" -eq 0 && -n "$PLUGIN" ]] || { error Cancel;return 1; }
  
  if zenity --question --text="Suppress plugin $PLUGIN ?" --title "Code Base Manager"; then
    get_plugins "$PROJECT"
    for p in "${PLUGINS[@]}"; do 
      [[ "$p"  == "$PLUGIN" ]] && break || { error internal; return 1; }
      ((n=n+1))
    done

    suppress_plugin "$PLUGIN" && error=0 || return "$?" 
    jq "del(.plugins[$n])|." "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json > "$PROJECT".tmp && mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
  else
    error Cancel
    error=1
  fi

  return "$error"  
  End
}

function suppress_plugin () {

  Start "$*"
  local error=0 plugin="$1"

  info " Suppression du plugin ${plugin}"
  get_plugin_dir "$plugin"
  cd "$MOODLE_SRC" || exit
  git checkout "$PROJECT_BRANCH" --quiet
  if [ -d "$MOODLE_SRC"/"$DIR"/"$COMPONENT_NAME" ]; then
    rm -r  "${MOODLE_SRC:-?}"/"${DIR:-?}"/"${COMPONENT_NAME:-?}"
    git add .
    git commit -m "Suppress plugin $plugin" --quiet
    success "$plugin deleted in codebase"      
  else
    warn "Plugin $plugin not present nothing to do!"
  fi
 
  End
  return "$error"

}

function add_plugin_project () {

  Start "$*"
  local error=0 plugin p list=''
  cd "$PLUGINS_REPO" || exit  
  for p in $(ls -l "$PLUGINS_REPO" | awk '{print $9}'); do
    # save plugins not in project configuration file
    if [[ -z $(jq -r '.plugins[].name' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json | grep "$p" ) ]]; then
      list+="FALSE $p "
    fi
  done
    
  #PLUGIN=$(menu --title "Plugins cache" --checklist "Plugin's List" 25 78 16 $list) && ret="$?" || ret="$?"
  PLUGIN=$(zenity --list --radiolist --text "Add plugin to project $PROJECT" --title "Code Base Manger Add plugin to project" \
    --column Use --column Plugin $list)
  error="$?"
  if [[ "$error" -eq 0 && -n "$PLUGIN" ]]; then
    [ "$DEBUG" = true ]&&info plugin selected: "$?" "$PLUGIN"
    if get_plugin_desired_state "$PLUGIN" "$MOODLE_VERSION" ; then
      jq  -r --arg plugin "$PLUGIN" '.plugins[.plugins| length] |= . + { "name": $plugin }' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json > "$PROJECT".tmp && mv "$PROJECT".tmp "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".json
      must_update_codebase=1    
    else
      error "$PLUGIN" version not supported
      error=1
    fi
  else
    error no plugin selection or cancel
  fi
  #get_plugins "$PROJECT"

  End
  return "$error"
}

function new_project_from_old () {

  local old_project="$1" new_project="$2"  error=0
  Start "$*"
  
  [ -f "$PROJECTS_PATH"/"$old_project"/"$old_project".json ] || { error "$PROJECTS_PATH"/"$old_project"/"$old_project".json not exists; error=1;}
  [ -f "$PROJECTS_PATH"/"$new_project"/"$new_project".json ] || { "$PROJECTS_PATH"/"$new_project"/"$new_project".json not exists; error=1;}
  jq -r '.plugins' "$PROJECTS_PATH"/"$old_project"/"$old_project".json > plugins.json
  jq  '.plugins += $inputs[]'  "$PROJECTS_PATH"/"$new_project"/"$new_project".json --slurpfile inputs plugins.json > newtmp.json && mv newtmp.json "$PROJECTS_PATH"/"$new_project"/"$new_project".json
  
  End
  return "$error"
}

function add_plugins_from_list () {

  local project="$1" filename="$2" plugin error=0 
  Start "$*"
  [[ -f "$filename" ]] || { error "$filename" not exists; error=1; }
  
  while read -r line; do    
    plugin=$(echo $line | cut -f 1 -d " ")
    info Add: "$plugin"
    # check if already included
    if [[ -n $(jq -r --arg plugin  "$plugin" '.plugins|map(select(.name == $plugin))[].name' "$PROJECTS_PATH"/"$project"/"$project".json;) ]]; then
      jq  -r --arg plugin "$plugin" '.plugins[.plugins| length] |= . + { "name": $plugin }' "$PROJECTS_PATH"/"$project"/"$project".json > "$project".tmp && mv "$project".tmp "$PROJECTS_PATH"/"$project"/"$project".json
    fi
  done < "$filename"

  End
  return "$error"

}